package net.ccbluex.liquidbounce.features.module.modules.exploit.disabler.other

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disabler.DisablerMode
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.IntegerValue
import net.minecraft.network.play.client.CPacketPlayer
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import java.util.*

class FakeFlagDisabler : DisablerMode("FakeFlag") {
    private val fakeLagBlockValue = BoolValue("${valuePrefix}Block", true)
    private val fakeLagPosValue = BoolValue("${valuePrefix}Position", true)
    private val fakeLagAttackValue = BoolValue("${valuePrefix}Attack", true)
    private val fakeLagSpoofValue = BoolValue("${valuePrefix}C03Spoof", false)
    private val fakeLagDelayValue = IntegerValue("${valuePrefix}Delay", 0, 0, 2000)
    private val fakeLagDurationValue = IntegerValue("${valuePrefix}Duration", 200, 100, 1000)

    private var isSent = false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()

    override fun onUpdate(event: UpdateEvent) {
        if (!fakeLagDelay.hasTimePassed(fakeLagDelayValue.get().toLong())) fakeLagDuration.reset()
        // Send
        if (fakeLagDuration.hasTimePassed(fakeLagDurationValue.get().toLong())) {
            fakeLagDelay.reset()
            fakeLagDuration.reset()
            for (packet in packetBuffer) {
                PacketUtils.sendPacketNoEvent(packet)
            }
            isSent = true
            packetBuffer.clear()
        }
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (fakeLagDelay.hasTimePassed(fakeLagDelayValue.get().toLong())) {
            if (isSent && fakeLagSpoofValue.get()) {
                PacketUtils.sendPacketNoEvent(CPacketPlayer(true))
                if (fakeLagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(CPacketPlayer(true))
                isSent = false
            }
            if (packet is CPacketKeepAlive || packet is CPacketConfirmTransaction) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
            if (fakeLagAttackValue.get() && (packet is CPacketUseEntity || packet is CPacketAnimation)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                if (packet is CPacketAnimation) return
            }
            if (fakeLagBlockValue.get() && (packet is CPacketPlayerDigging || packet is CPacketPlayerTryUseItemOnBlock || packet is CPacketAnimation)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
            if (fakeLagPosValue.get() && (packet is CPacketPlayer || packet is CPacketPlayer.Position || packet is CPacketPlayer.Rotation || packet is CPacketPlayer.PositionRotation || packet is CPacketEntityAction)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
        }
    }
}